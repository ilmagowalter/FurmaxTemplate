/**
 * FURMAX TEMPLATE
 * # FURMAX TEMPLATE REST api specifications Le api REST richiedono di effettuare il login tramite il servizio relativo, per ottenere il token di autenticazione. Le chiamate agli altri servizi devono contenere il token nell'header Authorization, es :    nome header: Authorization /   valore header: Bearer token   ---  ### Paginazione  La paginazione puo' richiedere al massimo 300 elementi  I servizi che prevedono paginazione hanno sempre in input  * pageSize - numero di elementi per pagina - default 20  * pageNumber - numero di pagina - default 1 
 *
 * OpenAPI spec version: 0.0.1
 * 
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent }                           from '@angular/common/http';
import { CustomHttpUrlEncodingCodec }                        from '../encoder';

import { Observable }                                        from 'rxjs';

import { ErroreGenerico } from '../model/erroreGenerico';
import { Utente } from '../model/utente';
import { UtentiPaginati } from '../model/utentiPaginati';

import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';


@Injectable()
export class UtentiService {

    protected basePath = 'http://localhost:8080/furmaxtemplate/rest';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string, @Optional() configuration: Configuration) {
        if (basePath) {
            this.basePath = basePath;
        }
        if (configuration) {
            this.configuration = configuration;
            this.basePath = basePath || configuration.basePath || this.basePath;
        }
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }


    /**
     * ricerca all&#39;interno degli utenti utenti
     * ritorna l&#39;elenco degli utenti, paginato e filtrato secondo input
     * @param pageSize numero di elementi per pagina
     * @param pageNumber numero della pagina da ritornare
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public utenteGet(pageSize?: number, pageNumber?: number, observe?: 'body', reportProgress?: boolean): Observable<UtentiPaginati>;
    public utenteGet(pageSize?: number, pageNumber?: number, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<UtentiPaginati>>;
    public utenteGet(pageSize?: number, pageNumber?: number, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<UtentiPaginati>>;
    public utenteGet(pageSize?: number, pageNumber?: number, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {



        let queryParameters = new HttpParams({encoder: new CustomHttpUrlEncodingCodec()});
        if (pageSize !== undefined && pageSize !== null) {
            queryParameters = queryParameters.set('pageSize', <any>pageSize);
        }
        if (pageNumber !== undefined && pageNumber !== null) {
            queryParameters = queryParameters.set('pageNumber', <any>pageNumber);
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];

        return this.httpClient.get<UtentiPaginati>(`${this.basePath}/utente/`,
            {
                params: queryParameters,
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * modifica un utente esistente
     * modifica un utente esistente
     * @param idUtente idUtente da modificare
     * @param utente dettagli dell&#39;utente da modificare
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public utenteIdUtentePut(idUtente: number, utente: Utente, observe?: 'body', reportProgress?: boolean): Observable<Utente>;
    public utenteIdUtentePut(idUtente: number, utente: Utente, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Utente>>;
    public utenteIdUtentePut(idUtente: number, utente: Utente, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Utente>>;
    public utenteIdUtentePut(idUtente: number, utente: Utente, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (idUtente === null || idUtente === undefined) {
            throw new Error('Required parameter idUtente was null or undefined when calling utenteIdUtentePut.');
        }

        if (utente === null || utente === undefined) {
            throw new Error('Required parameter utente was null or undefined when calling utenteIdUtentePut.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.put<Utente>(`${this.basePath}/utente/${encodeURIComponent(String(idUtente))}`,
            utente,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * crea un utente
     * crea un utente
     * @param utenti utenti da creare
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public utentePost(utenti: Utente, observe?: 'body', reportProgress?: boolean): Observable<Utente>;
    public utentePost(utenti: Utente, observe?: 'response', reportProgress?: boolean): Observable<HttpResponse<Utente>>;
    public utentePost(utenti: Utente, observe?: 'events', reportProgress?: boolean): Observable<HttpEvent<Utente>>;
    public utentePost(utenti: Utente, observe: any = 'body', reportProgress: boolean = false ): Observable<any> {

        if (utenti === null || utenti === undefined) {
            throw new Error('Required parameter utenti was null or undefined when calling utentePost.');
        }

        let headers = this.defaultHeaders;

        // authentication (APIKeyHeader) required
        if (this.configuration.apiKeys && this.configuration.apiKeys["Authorization"]) {
            headers = headers.set('Authorization', this.configuration.apiKeys["Authorization"]);
        }

        // to determine the Accept header
        let httpHeaderAccepts: string[] = [
            'application/json'
        ];
        const httpHeaderAcceptSelected: string | undefined = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        if (httpHeaderAcceptSelected != undefined) {
            headers = headers.set('Accept', httpHeaderAcceptSelected);
        }

        // to determine the Content-Type header
        const consumes: string[] = [
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected != undefined) {
            headers = headers.set('Content-Type', httpContentTypeSelected);
        }

        return this.httpClient.post<Utente>(`${this.basePath}/utente/`,
            utenti,
            {
                withCredentials: this.configuration.withCredentials,
                headers: headers,
                observe: observe,
                reportProgress: reportProgress
            }
        );
    }

}
